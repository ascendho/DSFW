# LRU 缓存

这张图展示了 LRU（最近最少使用）缓存的经典实现结构——哈希表与双向链表的组合，该结构用于同时满足“快速查找数据”和“按访问时序淘汰数据”的核心需求。

## 哈希表

左侧哈希表的主要作用是实现 O(1) 时间复杂度的快速查找，解决“如何快速判断数据是否在缓存中”的问题。其结构采用“桶+ 链地址法”处理哈希冲突：多个桶组成哈希表，每个桶对应一条链表，链表节点存储 Key，数据 data、以及指向后继节点的指针，其中 data 本身又是一个结构体或者指针/引用（当数据量大、复制成本高时），包括 key，value、以及指向队列中的结点指针 node。

## 双向链表（队列）

右侧的双向链表则用于维护数据的访问时序，解决“如何识别并淘汰‘最少最近使用’数据”的问题。其结构细节表现为：链表节点存储Key，以及 prev（前驱指针）和 next（后继指针），支持双向遍历与节点的快速插入/删除（无需扫描整个链表）。同时，链表的头部是“最少最近使用”的数据（缓存满时优先被淘汰），尾部是“最近使用”的数据（最后被淘汰）。

## 协同工作

哈希表与双向链表通过“指针”关联，形成“快速查找 + 时序追踪”的闭环，实现协同工作。当访问某个 Key 时，哈希表先通过 Key 快速定位到对应项，再通过哈希表项中的“链表节点指针”找到该 Key 在双向链表中的位置，最后将该节点移动到双向链表的尾部（标记为“最近使用”，避免被误淘汰）。而当缓存已满需淘汰数据时，会直接删除双向链表的头部节点（即“最少最近使用”的数据），并同步通过节点中的 Key 从哈希表中移除对应项，为新数据腾出空间。这种“哈希表 + 双向链表”的组合，让 LRU 缓存同时具备“快速查找效率”和“按访问时序淘汰的能力”，是平衡缓存“速度”与“容量”的经典设计。