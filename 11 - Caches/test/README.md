# LRU Cache 测试说明

## 文件结构

```
test/
├── test_lru_cache.cpp    # LRU Cache 测试程序
└── README.md             # 本文件
```

## 编译和运行

### 编译测试程序

```bash
cd "/Users/ascendho/Downloads/book/dstfw/11 - Caches"
g++ -std=c++17 -o test/test_lru_cache test/test_lru_cache.cpp -I.
```

### 运行测试

```bash
./test/test_lru_cache
```

## 测试用例说明

### 测试1: 基本操作
- **目的**: 验证基本的缓存查找和缓存命中功能
- **测试内容**:
  - 第一次访问键时从慢速数据源获取数据
  - 第二次访问相同键时从缓存获取（缓存命中）

### 测试2: 缓存容量限制
- **目的**: 验证缓存容量限制和淘汰机制
- **测试内容**:
  - 填满容量为3的缓存
  - 访问已缓存的键，验证缓存命中
  - 添加新键时，验证最旧的键被移除
  - 验证被移除的键需要重新从数据源获取

### 测试3: LRU顺序验证
- **目的**: 验证最近最少使用（LRU）的淘汰策略
- **测试内容**:
  - 填充缓存后，访问旧键更新其使用时间
  - 添加新键时，验证最久未使用的键（而非最旧的键）被移除
  - 验证recently访问过的键仍保留在缓存中

### 测试4: 字符串类型缓存
- **目的**: 验证泛型实现对不同数据类型的支持
- **测试内容**:
  - 使用 `std::string` 作为键和值类型
  - 验证所有基本功能在字符串类型下正常工作

### 测试5: 容量为1的缓存
- **目的**: 验证边界情况
- **测试内容**:
  - 测试容量为1的极限情况
  - 验证每次添加新键都会替换唯一的缓存项

## 测试结果

所有测试都成功通过，验证了 LRU Cache 实现的正确性：

✓ 基本缓存查找和命中功能正常
✓ 容量限制和淘汰机制正确
✓ LRU（最近最少使用）策略正确实施
✓ 泛型实现支持多种数据类型
✓ 边界情况处理正确

## 实现要点

LRU Cache 的实现严格按照伪代码规范：

1. **哈希表查找**: 使用 `std::unordered_map` 快速查找缓存条目
2. **队列管理**: 使用双向链表队列跟踪访问顺序
3. **容量控制**: 当缓存满时，通过出队操作移除最旧的条目
4. **数据源集成**: 通过函数对象模拟慢速数据源
5. **位置更新**: 缓存命中时，移除旧节点并重新入队，保持LRU顺序

## 性能特点

- **时间复杂度**:
  - 查找: O(1) - 哈希表查找
  - 插入: O(1) - 队列入队和哈希表插入
  - 删除: O(1) - 队列出队和哈希表删除
  
- **空间复杂度**: O(n)，其中 n 是缓存容量
